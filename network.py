from typing import Optionalimport torch.nn as nnimport torch.optim as optimfrom pytorch_lightning import LightningModulefrom torchmetrics import Accuracy, F1from model import CMGclass CMGNetwork(LightningModule):    def __init__(self,                 freeze: Optional[bool]=False,                 n_classes: Optional[int]=20,                 gd: Optional[int]=2):        super().__init__()        self.model = CMG(freeze=freeze,                         n_classes=n_classes,                         gd=gd)        self.loss_fn_aux = nn.NLLLoss()        self.loss_fn_gd = nn.TripletMarginLoss()        self.acc = Accuracy()        self.f1 = F1(num_classes=20)    def configure_optimizers(self):        param_aux = [param[1] for param in self.model.named_parameters() \                     if param[0].split('.')[0] == 'backbone' or param[0].split('-')[0] == 'clf']        optimizer_aux = optim.AdamW(param_aux, lr=1e-4)        param_gd = [param[1] for param in self.model.named_parameters() \                    if param[0].split('-')[0] == 'emb']        optimizer_gd = optim.AdamW(param_gd, lr=1e-4)        return [optimizer_aux, optimizer_gd]    def forward(self, x):        return self.model(x)    def training_step(self, batch, batch_idx, optimizer_idx):        images, labels = batch        outputs = [self(img) for img in images]        y_hats, embs = [], []        for out in outputs:            y_hats.append(out[0])            embs.append(out[1])        aux_losses = [self.loss_fn_aux(y_, label) for y_, label in zip(y_hats, labels)]        triplet_loss = self.loss_fn_gd(*embs)        loss = sum(aux_losses) / 3 + triplet_loss        self.log('train_aux_loss_step', sum(aux_losses) / 3, on_step=True, on_epoch=False, prog_bar=True)        self.log('train_triplet_loss_step', triplet_loss, on_step=True, on_epoch=False, prog_bar=True)        self.log('train_aux_loss_epoch', sum(aux_losses) / 3, on_step=False, on_epoch=True, prog_bar=False)        self.log('train_triplet_loss_epoch', triplet_loss, on_step=False, on_epoch=True, prog_bar=False)        self.log('train_loss', loss, on_step=True, on_epoch=True, prog_bar=False)        return {'loss': loss}    def validation_step(self, batch, batch_idx):        images, labels = batch        outputs = [self(img) for img in images]        y_hats, embs = [], []        for out in outputs:            y_hats.append(out[0])            embs.append(out[1])        aux_losses = [self.loss_fn_aux(y_, label) for y_, label in zip(y_hats, labels)]        [self.acc(preds=y_, target=label) for y_, label in zip(y_hats, labels)]        [self.f1(preds=y_, target=label) for y_, label in zip(y_hats, labels)]        triplet_loss = self.loss_fn_gd(*embs)        loss = sum(aux_losses) / 3 + triplet_loss        self.log('val_aux_loss', sum(aux_losses) / 3, on_step=False, on_epoch=True, prog_bar=False)        self.log('val_triplet_loss', triplet_loss, on_step=False, on_epoch=True, prog_bar=False)        self.log('val_loss', loss, on_step=False, on_epoch=True, prog_bar=False)        self.log('Accuracy', self.acc, on_step=False, on_epoch=True)        self.log('F1', self.f1, on_step=False, on_epoch=True)        return {'loss': loss}