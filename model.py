from typing import Optionalimport torch.nn as nnfrom torchvision.models import resnet50from pooling import *class CMG(nn.Module):    def __init__(self,                 freeze: Optional[bool] = False,                 n_classes: Optional[int] = 20,                 gd: Optional[int] = 0):        super().__init__()        # Backbone Model        self.backbone = resnet50(pretrained=True)        if freeze:            for param in self.backbone.parameters():                param.requires_grad = False        in_features = self.backbone.fc.in_features        del self.backbone.avgpool, self.backbone.fc        self.gd = gd        # Combination of Multiple        self.flatten = nn.Flatten()        # Pooling Layers        spoc = SPoC();        mac = MAC();        gem = GeM()        self.pooling = [spoc, mac, gem]        # Auxiliary Module        self.clf = nn.Sequential(            nn.BatchNorm1d(in_features),            nn.ReLU(),            nn.Linear(2048, 512),            nn.ReLU(),            nn.Linear(512, n_classes),            nn.LogSoftmax()        )        # FCs        for n in range(len(self.pooling)):            emb = nn.Linear(2048, 512)            setattr(self, f'emb-{n}', emb)    def forward(self, x):        # Feature Extracting        feature = x        for name, module in self.backbone.named_children():            feature = module(feature)        pooling_outputs = [self.flatten(pool(feature)) for pool in self.pooling]        # Auxiliary Module & Global Descriptor        gd = []        for n, output in zip(range(len(self.pooling)), pooling_outputs):            emb = getattr(self, f'emb-{n}')            gd.append(F.normalize(emb(output)))        y_hat = self.clf(pooling_outputs[self.gd])        return y_hat, torch.cat(gd, -1)